#!/bin/bash
# Script que genera las urls para descargar los puntos de plocalse.

# Raquel Lorente Plazas <raquel@meteored.com> 02/2021
# Marcos Molina Cano <marcos@meteored.com>
# Guillermo Ballester Valor <gbv@ogimet.com>
# Juan Sanchez Segura <jsanchez@meteored.com>
# Laura Palacios Peña <laura@meteored.com>
###############################################################################

export LANG=C
# Nombre del script.
scriptName=$(basename "$0")

# Formato de fecha
function datePID {
 echo "$(date -u +%Y/%m/%d\ %H:%M:%S.%3N) UTC [$$]"
  }

# Función que define la ayuda sobre este script.
function showUse {
  echo
  echo "Uso: ${scriptName} HH [-d|--date AAAAMMDD] [-D|--Day -1|-2] [-c|--check] [-h|--help]"
  echo
  echo "Opciones:"
  echo "  HH"
  echo "      00 para la pasada de las 00 UTC y 12 para la pasada de las 12 UTC."
  echo "  [-d|--date AAAAMMDD|[-1|-2]]"
  echo "      Puede ser AAAAMMDD que es la fecha de la pasada o -1 o -2 que es el número"
  echo "      a restar al día actual. Por ejemplo, -1 sería la pasada de ayer y -2 sería antes de ayer."
  echo "  [-D|--Day -1|-2]"
  echo "      Se resta un día a la fecha. Se usa si se ejecuta el script el día siguiente al que quiere validarse"
  echo "  [-c|--check]"
  echo "      Se muestran archivos de chequeo."
  echo "  [-h|--help]"
  echo "      Se muestra esta ayuda."
  echo ""
}



LOCK_FILE=${scriptName}.lock
FINISHED=finished_${scriptName}

# Si existe el fichero de bloqueo comprobamos su antigüedad y salimos.
[[ -e ${LOCK_FILE} ]] && [[ $(stat -c %Y "${LOCK_FILE}") -gt $(date -u +%s --date="20 minutes ago") ]] && exit

# Podemos comenzar. Creamos el directorio donde irán los json y nos movemos a él.
touch "${LOCK_FILE}"

# Se definen los roles de los servidores según su DNS.
if [[ -s /usr/local/share/ogimet/servers.conf ]] ; then
  source /usr/local/share/ogimet/servers.conf
else
  OTF_1="aguila.ogimet.com"
  OTF_2="halcon.ogimet.com"
  OTF_3="azor.ogimet.com"
fi

function plocales_urls {

  first=$1
  last=$2
  inc=1
  SERVER="${OTF_1}"

  if [[ -z "$SERVER" ]]; then
    echo "Rapaz vacía. Ejecutar con -a "
    exit 1
  fi

  for (( i = "${first}"; i <= "${last}"; i += "${inc}" )) ; do

    cod_pgeo=$(mysql -uogimet plocales -se "select cod_pgeo from puntos where cod_pgeo = ${i}")
    nombre=$(mysql -uogimet plocales -se "select nombre from puntos where cod_pgeo = ${i}" | sed -e 's/ /%20/g')
    id_tiempo=$(mysql -uogimet plocales -se "select id_tiempo from puntos where cod_pgeo = ${i}")
    latitud=$(mysql -uogimet plocales -se "select latitud from puntos where cod_pgeo = ${i}")
    longitud=$(mysql -uogimet plocales -se "select longitud from puntos where cod_pgeo = ${i}")
    altitud=$(mysql -uogimet plocales -se "select altitud from puntos where cod_pgeo = ${i}")
    zona_horaria=$(mysql -uogimet plocales -se "select zoneinfo from puntos where cod_pgeo = ${i}" | sed -e 's/\//%2f/g')
    #FIXME ver si la zona horaria es utc
   # zona_horaria=UTC

    if [[ "${SERVER}" == "${OTF_1}" ]]; then
      SERVER="${OTF_2}"
    elif [[ "${SERVER}" == "${OTF_2}" ]]; then
      SERVER="${OTF_3}"
    elif [[ "${SERVER}" == "${OTF_3}" ]]; then
      SERVER="${OTF_1}"
    fi
    #echo "Escribiendo urls "$first" "$last""
    echo "$longitud" "$latitud" "'http://"$SERVER"/cgi-bin/otf12?pasada=AAAAMMDDHH&latitud="$latitud"&longitud="$longitud"&altitud="$altitud"&zonaHoraria='"${zona_horaria}"'&name='"${nombre}"''" "${id_tiempo}".json >> tmp_urls_plocales_"$first"_"$last".txt
  done
  sort -n tmp_urls_plocales_"$first"_"$last".txt | awk '{print $3}' > sort_urls_plocales_"$first"_"$last".txt
  rm tmp_urls_plocales_"$first"_"$last".txt

}


# Sacamos el cod_pgeo máximo para dividir la tarea en bloques de ${inc} puntos.
cod_pgeo_min=1
cod_pgeo_max=$(mysql -uogimet plocales -se "select cod_pgeo from puntos order by cod_pgeo desc limit 1")
inc=10000

# Bucle que crea los json de localidades. Para cada paquete se crea
# un fichero testigo llamado first-last.tst que marca que se ha generado.
echo "$(datePID) Comienza la generación del txt con urls names ... "
export -f plocales_urls

for (( i = cod_pgeo_min; i <= cod_pgeo_max ; i += inc )) ; do

  first=${i}
  last=$(( i + inc - 1 ))

  # Si last es mayor que cod_pgeo_max forzamos cod_pgeo_max para que
  # no haya problemas en la generación de json y listados.
  [[ ${last} -gt ${cod_pgeo_max} ]] && last=${cod_pgeo_max}

  # Fichero testigo de bloque.
  tst=plocales_${first}-${last}.tst

  [[ -e ${tst} ]] || echo "touch ${LOCK_FILE} && plocales_urls ${first} ${last} && touch ${tst}"
done | parallel -j 10
# Si llega aquí se han generado correctamente los json.
rm ./plocales_*-*.tst
touch "${FINISHED}"

# Se borra fichero de bloqueo y salimos.
rm "${LOCK_FILE}"
echo "$(datePID) ... finalizada."
#gcc -o Consulta $(mysql_config --cflags) read_write_mysql.c $(mysql_config --libs)
cat localidades_por_celdas.txt | head -614 | awk '{print "'http://localhost/cgi-bin/'"$3}' | sed -e s/AAAAMMDDHH/2021030800/g | sed -e 's/\//%2f/g' > estaciones-celda-aleatoria.txt
cat localidades_por_celdas.txt | awk '{if ($1==1306 && $2==2481) print "http://localhost/cgi-bin/"$3}' | sed -e s/AAAAMMDDHH/2021030800/g | sed -e 's/\//%2f/g' > estaciones-celda-aleatoria.txt